# ------------------ Physical Models ----------------------------------- # 
# 
# This module contains all the functions that have to do with the physics of our simulations. 
# From Calculating the amount of particles heating the wire, to the current generation to the cooling 
# processes.
#


import numpy as np
import math
import sys
from Modules import MaterialBank as mb
from Modules import NecessaryVariables as nv


# ------------------------- Creating Particle Matrix ----------------------- # 

# The proportion of particles heating each point in space is stored in a matrix. 
# This matrix has thhe same size as the detector geometry, at the end we are only 
# interested in knowing how many particles heat each part of the detector. 
# This matrix is constructed either by reading the input file with the particle 
# distribution, or it is calculated from a gaussian function. 
#

def CreateNiMatrix():
    def FindMatrixValue(x,y,Mat):
        if ((x < Mat[0][0]) or (x > Mat[-1][0])): val = 0
        elif ((y < Mat[0][1]) or (y > Mat[-1][1])): val = 0
        else:
            for i in range(0,len(Mat)):
                if ((x < Mat[i][0]) and (y < Mat[i][1])): break
            
            val = Mat[i][2]
        return val

    Nmat = np.zeros([len(nv.xvec),len(nv.yvec)])
    print(len(nv.yvec))
    if nv.BeamType == "Gaussian":
        for k in range(len(nv.xvec)):
            for j in range(len(nv.yvec)):
                Ni = (1.0/(2*math.pi*nv.sigx*nv.sigy))*np.exp(-0.5*(((nv.xvec[k]-nv.x0)/nv.sigx)**2+((nv.yvec[j]-nv.y0)/nv.sigy)**2))
                # change ms: 20240405
                #Nmat[k,j] = Ni*1e-4  # sigx,y are in meters so Ni is in 1/m2 , why convert to 1/cm2?
                Nmat[k,j] = Ni  # sigx,y are in meters, Ni is 1/m2                
    else: 
        for i,x in enumerate(nv.xvec,0):
            for j,y in enumerate(nv.yvec,0):
                # first find corresponding element in BeamMatrix. 
                val = FindMatrixValue(x,y,nv.Mat_BeamShape)
                Nmat[i][j] = val*1e-4
    
    # debugging
    #with open('debug.txt','a') as fp:
        #fp.write(str(Nmat[0][5]+','+str(Nmat.sum()))+'\n')
        #fp.write(str(Nmat.sum())+'\n')
    # this shows roughly corectness
    #exit()
    # to do: compute correction due to the binning!!!
    # to do: skew gaussian option 
    return Nmat


# --------------------------------- Calculate Number of Particles ---------------------------- #

#
# Now we multiply the Matrix that was calculated in the previous funtion by the total number of particles. 
# This gives us the total number of particles heating each point in the detector. 
#

def NumberParticles(Ntot):
    '''
    Gives you the number of particles reaching each part of the detector when the beam..
    '''
    Nmat = Ntot*nv.ParticleProportionMatrix
    
    return Nmat

#------------------------- Current Calculation -------------------------------------------- # 

# 
# This function calculates the current generated in the detector at each time step. 
# Npart is just 1.0 or 0.0

def CalculateCurrent(Npart,Temperature,numberStepPulse,dt):
   
    # First we calculate how much charge each incident generates in the material. 
    # Qtot = Qdep + Qse + Qje
    # Total charge accounts for the deposited charge, the secondary emission charge and the thermionic charge. 
    # 
    
    # 1) Deposited charge, depends on the amount of electrons and protons that stay in the detector material. 
    #
    
    Qdep = nv.Particle.Nprotons*nv.Eta - nv.Particle.Nelectrons*nv.Mu

    # 2) Secondary Emission, has to do with how many electrons leave the material per incident particle. 
    # It is characterized by the SEY, secondary emission yield. We have the SEY generated by the incident 
    # protons and the SEY generated by the incident electrons. 
    # 
    
    Nv = nv.Na*nv.Material.rho/nv.Material.Am   # [atoms/cm3]
    # 3.68e-17 is a constant with unit of [cm2], see D.Kramer thesis page 29-30
    Ls = 1.0/(3.68e-17*Nv*nv.Material.Z**(1/3.))  # [cm]

    # ms, 20230808:    
    #SEYp = 0.01*Ls*nv.enemat*1e+6*nv.Material.rho*(1.0+1.0/(1.0+(5.4*float(nv.BEnergy)/(nv.Particle.PartMass*nv.Amu))))
    # nv.enemat is dE/dx in [MeV*cm2/g] and it needs to be converted to eV/cm
    
    SEYp = 0.01*Ls*nv.enemat*1e+6*nv.Material.rho*(1.0+1.0/(1.0+(5.4*float(nv.BEnergy)/(nv.Particle.PartMass*nv.kgMeV))))
    SEYe = 0.01*Ls*nv.Ele_enemat*1e+6*nv.Material.rho

    # ms, 20230808:
    #Qse_p = nv.Particle.Nprotons*(1-nv.Eta)*SEYp + nv.Particle.Nprotons*nv.BEp*SEYp 
    # nv.Eta - fraction of protons stopped in the material (thin targets: 0)
    # nv.BSp - fraction of backscatterted protons (they also cross the wire surface twice)
    Qse_p = nv.Particle.Nprotons*(1-nv.Eta)*SEYp + nv.Particle.Nprotons*nv.BEp*SEYp + nv.Particle.Nprotons*SEYp   
    Qse_e = nv.Particle.Nelectrons*(1-nv.Mu)*SEYe + nv.Particle.Nelectrons*nv.BEe*SEYe 
    
    
    # Here we add upp the aforecalculated charges, deposited charge and SE charge. 
    # Q is number of charges generated per impacting beam particle
    
    Q = Qdep + Qse_p + Qse_e  # 2024.04.05 - check if here should be minus Qse_e


    # Current Due to thermoionic emission. This term highly depends on the temperature of the detector at each point. 
    #
 
    # eSup is vector of surfaces of each bin of the wire [m2]
    # RH is Richardson constant 120.173	 [A/cm2 K2] - factor 1e4 converts it to to [A/m2 K2]   
    # wfun is material work function [eV]
    #thcurrent = nv.eSup*1e+4*nv.RH*Temperature**2*np.exp(-nv.Material.wfun*nv.Qe/(nv.BZ*Temperature))   # Current [A]
    thcurrent = nv.eSup*1e4*nv.RH*Temperature**2*np.exp(-nv.Material.wfun*nv.Qe/(nv.BZ*Temperature))   # Current [A]

    
    #
    # Number of particles reaching each spot in the geometry, it is used to calculate the total current. 
    
    nparts = Npart*NumberParticles(nv.Nparticles) / numberStepPulse
    
    # Calculate Current in each point of space due to Charge deposition and SEY. [A/m2]
    # Here we transform the charge calculated before to current. 

    Super_Q = nparts*Q*nv.Qe/dt   # [A]
    
    # At this stage we have a matrix with the amount of current generated in each point in space, 
    # but we are interested in how much total current is generated in the detector, so we need to add up 
    # all this currents. 
    # This is slightly different for every type of detector, for example in a wire scanner we will integrate 
    # along the single wire lenght. For a SEM grid we have to integrate each wire sepparatelly in case there are 
    # more than one. And in the foil we need to integrate both spatial coordinates. 
    # We have sepparated the current in two different ones. 
    # Current1 does not account for thermionic emission. Current2 accounts for thermionic emission. This might 
    # give us information about the thermal contribution. 
    #
    

    if nv.DetType == "SEM":
        Surf = nv.SEM_wWidth*nv.SEM_wRes
        Current1 = []; Current2 = []
        if nv.SEM_Plane == "Vertical":
            Super_Q = Super_Q.copy().transpose()
        for k in range(0,len(Super_Q)):
            Current1 += [Surf*np.sum(Super_Q[k,:])]                           # Current  Without Thermoionic emission [A]
            Current2 += [Surf*np.sum(Super_Q[k,:])+np.sum(thcurrent[k,:])]      # Current With Thermoionic Emission [A] 
   
    elif nv.DetType == "FOIL":
        Surf = nv.FOIL_xwidth/nv.FOIL_nx * nv.FOIL_ywidth/nv.FOIL_ny
        Current1 = 0.0; Current2 = 0.0
        for k in range(0,len(Super_Q)):
            for j in range(0,len(Super_Q[k])):
                Current1 += Surf*Super_Q[k][j]
                Current2 += Surf*Super_Q[k][j]+Surf*thcurrent[k][j]

    
    elif nv.DetType == "WIRESCAN":
        # ms: 20230808
        # following Manon's suggestion:
        # Surf = nv.WIRESCAN_wRes*nv.WIRESCAN_wWidth*1e4            # 1e4? [cm2]?
        Surf = nv.WIRESCAN_wRes*nv.WIRESCAN_wWidth                  # [m2] - number of particles crossing the wire in each bin
        Current1 = Surf*np.sum(Super_Q[0,:])                            # Current  Without Thermoionic emission [A]
        Current2 = np.sum(thcurrent[0,:])                     # Current With Thermoionic Emission [A] 
        #Current1 = np.sum(Super_Q[0,:])                            # Current  Without Thermoionic emission [A]
        #Current2 = np.sum(thcurrent[0,:])       # Thermoionic Emission current [A] 
        # add Current3 delta electrons


    return Current1, Current2

# -------------------------------------------- BEAM HEATING -------------------------------- # 
#
# Calculates the beam heating of each space segment at a given instant of time. We are considering that 
# the heating will be always the same during the beam pulse.
# 2024.03.29 - add sum of the number of particles to the output

def BeamHeating(Temperature, numberStepPulse):
    
   
    if (nv.DetType == "WIRESCAN") and (nv.WIRESCAN_Type == 1):
        dt = numberStepPulse
        # ms: 20230808, after Manon:
        #nparts = NumberPartcles(nv.Nparticles)*dt*nv.frec   # synchrotron beam
        nparts = NumberParticles(nv.Nparticles)               # cyclotron beam        
    else:
        nparts = NumberParticles(nv.Nparticles) / numberStepPulse

    dtemp =  nparts *  (nv.enemat+nv.Ele_enemat*nv.Particle.Nelectrons*nv.Mu)*1e+6*nv.Qe / nv.Material.CpT
    
    # As an output we obtain the temperature variation for each point.    
    # 2024.03.30: include also total number of particles in output, do we need it? We have nv.Nparticles
    # verify
    return np.asanyarray(dtemp),nparts.sum()

# ---------------------------------- Radiative Cooling -------------------------- # 

def RadiativeCooling(dt, Temperature):

    '''
     Here radiative cooling is calculated
     Arguments:
        dt: [s] Is considered the duration of the cooling process. Normally it is defined by default but if
            if the conditions don't change too fast can be increased in order to make the simulation faster.
        Temperature: [K] Temperature Matrix.
    :return: temperature reduction (negative sign)
    '''

    cp = nv.Material.CpT
    eps = nv.Material.epsT
    dene = nv.eSup * nv.ST * eps * (Temperature ** 4 - (nv.T0 ** 4) * Temperature ** 0) * dt
    dtemp = -dene / (cp * nv.eVol * nv.Material.rho * 1e+6)

    return dtemp

# ------------------------------- Thermionic Cooling --------------------------------------- # 

# to do: correct name
def ThermoionicCooling(dt,Temperature):
    '''
    Here thermoionic cooling is calculated
    :param dt: [s] time duration of the cooling process.
    :param Temperature: [K] Temperature Matrix
    :return: temperature reduction (negative sign)
    '''
    
    # thcurrent should be a single function! It is defined twice.
    # 1.602e-19 - use Qe 
    thcurrent = nv.eSup*1e4*nv.RH*Temperature**2*np.exp(-nv.Material.wfun*1.602e-19/(nv.BZ*Temperature))
    dene = (nv.Material.wfun*1.602e-19+(2*nv.BZ*Temperature))*thcurrent*dt/nv.Qe
    dtemp = -dene/(nv.Material.CpT*nv.eVol*nv.Material.rho*1e+6)

    return dtemp

# --------------------------------- Conductive cooling --------------------------------- # 

def ConductiveCooling(dt, Temperature):
    '''
    Here Conductive cooling is calculated
    :param dt: [s] time duration of cooling process.
    :param Temperature: [K] Temperature matrix. 
    :return: Temperature variation. 
    '''
    
    dtemp = 0.0*Temperature

    # --------------- This is based on the FTCS method --------------- $
    
    def Calculate_dTemp(posvec1,posvec2,Temperature,dt,dx):
        Tbott = 300.0; Tupp = 300.0 
        for k in range(0,len(posvec1)):
            for j in range(0, len(posvec2)):
                Tj = Temperature[k][j]
                alpha = nv.Material.con[k][j]/(nv.Material.rho*nv.Material.CpT[k][j]*1e+6)
                r = alpha*dt/dx**2
                if j == 0:
                    Tjp1 = Temperature[k][j+1]
                    Tjm1 = Tbott
                elif j == len(posvec2)-1:
                    Tjp1 = Tupp
                    Tjm1 = Temperature[k][j-1]
                else:
                    Tjp1 = Temperature[k][j+1]
                    Tjm1 = Temperature[k][j-1]

                dtemp[k][j] = r*(Tjp1-2*Tj+Tjm1)
        return dtemp

    # Two possible cases, 
    #       for SEM Grids and Wire scanners only conduction in one direction. 
    #       for FOILs conduction in direction x and y. 

    if nv.DetType != "FOIL":
        #-----------------------------------------------#
        # posvec1: Position of Wire Center.             #
        # posvec2: Central position of wire fragment.   #
        #-----------------------------------------------#
        if (nv.DetType == "SEM") and (nv.SEM_Plane == "Horizontal"):
            posvec1 = nv.xvec.copy()
            posvec2 = nv.yvec.copy()
            dx = nv.SEM_wRes
            Calculate_dTemp(posvec1,posvec2,Temperature,dt,dx)
        # ms: 20230808, following Manon
        #elif (nv.DetType == "WIRESCAN") and (nv.WIRESCAN_Plane == "Vertical"):
        elif (nv.DetType == "WIRESCAN") and (nv.WIRESCAN_Plane == "Horizontal"):    
            posvec1 = nv.xvec.copy()
            posvec2 = nv.yvec.copy()
            dx = nv.WIRESCAN_wRes
            Calculate_dTemp(posvec1,posvec2,Temperature,dt,dx)
        elif (nv.DetType == "SEM") and (nv.SEM_Plane == "Horizontal"):
            posvec1 = nv.yvec.copy()
            posvec2 = nv.xvec.copy()
            dx = nv.SEM_wRes
            Temperature = Temperature.transpose()
            nv.Material.con = nv.Material.con.transpose()
            nv.Material.CpT = nv.Material.CpT.transpose()
            dtemp = dtemp.transpose()
            # ---------------------------------------------- #
            dtemp = Calculate_dTemp(posvec1,posvec2,Temperature,dt,dx)
            # ---------------------------------------------- #
            Temperature = Temperature.transpose()
            nv.Material.con = nv.Material.con.transpose()
            nv.Material.CpT = nv.Material.CpT.transpose()
            dtemp = dtemp.transpose()
        elif (nv.DetType == "WIRESCAN") and (nv.WIRESCAN_Plane == "Vertical"):
            posvec1 = nv.yvec.copy()
            posvec2 = nv.xvec.copy()
            dx = nv.SEM_wRes
            Temperature = Temperature.transpose()
            nv.Material.con = nv.Material.con.transpose()
            nv.Material.CpT = nv.Material.CpT.transpose()
            dtemp = dtemp.transpose()
            # ---------------------------------------------- #
            dtemp =  Calculate_dTemp(posvec1,posvec2,Temperature,dt,dx)
            # ---------------------------------------------- #
            Temperature = Temperature.transpose()
            nv.Material.con = nv.Material.con.transpose()
            nv.Material.CpT = nv.Material.CpT.transpose()
            dtemp = dtemp.transpose()

        
    else:
        # - Calculate conductive cooling for FOILS. By solving 2d Heat equation - #  
        #       Tij = T[i][j]; Tim1 = T[i-1][j]; Tip1 = T[i+1][j]                 #
        #                      Tjm1 = T[i][j-1]; Tjp1 = T[i][j+1]                 #
        # ----------------------------------------------------------------------- #

        dx = nv.FOIL_xwidth/nv.FOIL_nx; dy = nv.FOIL_ywidth/nv.FOIL_ny

        Tbott = 300.0; Tupp = 300.0 ; Tright = 300.0; Tleft = 300.0
        for i in range(0,len(nv.xvec)):
            for j in range(0,len(nv.yvec)):
                Tij = Temperature[i][j]
                alpha = nv.Material.con[i][j]/(nv.Material.rho*nv.Material.CpT[i][j] * 1e+6)
                rx = alpha*dt/dx**2; ry = alpha*dt/dy**2
                
                if (i == 0) and (j == 0): 
                    Tim1 = Tleft; Tjm1 = Tbott
                    Tip1 = Temperature[i+1][j]; Tjp1 = Temperature[i][j+1]
                elif (i == len(nv.xvec)-1) and (j == len(nv.yvec)-1): 
                    Tim1 = Temperature[i-1][j]; Tjm1 = Temperature[i][j-1]
                    Tip1 = Tright; Tjp1 = Tupp

                else:
                    try: Tim1 = Temperature[i-1][j]; Tip1 = Temperature[i+1][j] 
                    except IndexError:
                        if (i == 0): Tim1 = Tleft
                        elif (i == len(nv.xvec)-1): Tip1 = Tright
                    try: Tjm1 = Temperature[i][j-1]; Tjp1 = Temperature[i][j+1]
                    except IndexError:
                        if (j == 0): Tjm1 = Tbott
                        elif (j == len(nv.yvec)-1): Tjp1 = Tupp
                dtemp[i][j] = ry*(Tjp1-2*Tij+Tjm1)+rx*(Tip1-2*Tij+Tim1)
    return dtemp

# ------------------------------- Sublimation Cooling ---------------------------------- # 

def SublimationCooling(dt, Temperature):
    '''
        This function calculates the sublimation rate of the material due to temperature. 
        The model is based on " Scientific fundatios of Vacuum techniques", S. Dushman.  Eq. 10.09.
        :return: Temperature reduction (negative sign)
    '''
    dtemp = Temperature * 0.0
    for i in range(0,len(Temperature)):
        for j in range(0,len(Temperature[i])):
            Tij = Temperature[i][j]
            Log_W = nv.Material.Sublimation_C1 - 1/2.*np.log(Tij) - nv.Material.Sublimation_C2/Tij
            sub_W = math.pow(10.0, Log_W)                           # [g / cm2 / s]   material sublimation rate
            sub_Wdt = sub_W * dt * 10000                            # [g / cm2 / s] -> [g / m2]
            Wdt = sub_Wdt*nv.eSup * nv.Material.Am                  # [J]     
            dtemp[i][j] = -Wdt*nv.Material.HT[i][j] / (nv.Material.CpT[i][j] * nv.eVol * 1e+6 * nv.Material.rho )            # [ K ]

    return dtemp

# ------------------------  Linear thermal expanison --------------------------------- 

# This attempts to calculate the thermal expanison of the detecotrs, but it is not currently being used.  

def LinearThermalExpansion(Temperature):

    dL_vec = []
    for j in range(0,len(Temperature)):
        dL = 0.0
        for i in range(0,len(Temperature[j])):
            dL += nv.SEM_wRes*nv.Material.expcoeff*(Temperature[j][i]-nv.T0)

        dL_vec.append(dL)
    
    return dL_vec
